<HTML
><HEAD
><TITLE
>Control Structures</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.41"><LINK
REL="HOME"
TITLE="PHP3 Manual"
HREF="manual.html"><LINK
REL="UP"
TITLE="Syntax and grammar"
HREF="lang-syntax.html"><LINK
REL="PREVIOUS"
TITLE="Operators"
HREF="operators.html"><LINK
REL="NEXT"
TITLE="Function Reference"
HREF="funcref.html"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PHP3 Manual</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="operators.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 5. Syntax and grammar</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="funcref.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="CONTROL-STRUCTURES"
>Control Structures</A
></H1
><P
>    Any PHP script is built out of a series of statements. A statement can
    be an assignment, a function call, a loop, a conditional statement of
    even a statement that does nothing (an empty statement). Statements
    usually end with a semicolon. In addition, statements can be grouped
    into a statement-group by encapsulating a group of statements with
    curly braces. A statement-group is a statement by itself as well. The
    various statement types are described in this chapter.

   </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CONSTRUCT.IF"
><TT
CLASS="LITERAL"
>if</TT
></A
></H2
><P
>     The <TT
CLASS="LITERAL"
>if</TT
> construct is one of the most important
     features of many languages, PHP included.  It allows for conditional
     execution of code fragments.  PHP features an <TT
CLASS="LITERAL"
>if</TT
>
     structure that is similar to that of C:

     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> if (expr)
     statement
 </PRE
><P
></P
></DIV
>
 
    </P
><P
>     As described in the section about expressions, expr is evaluated
     to its truth value.  If <TT
CLASS="REPLACEABLE"
><I
>expr</I
></TT
> evaluates
     to <TT
CLASS="LITERAL"
>TRUE</TT
>, PHP will execute statement, and if it
     evaluates to <TT
CLASS="LITERAL"
>FALSE</TT
> - it'll ignore it.
 
    </P
><P
>     The following example would display <TT
CLASS="COMPUTEROUTPUT"
>a is bigger
     than b</TT
> if <TT
CLASS="REPLACEABLE"
><I
>$a</I
></TT
> is bigger
     than <TT
CLASS="REPLACEABLE"
><I
>$b</I
></TT
>:
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> if ($a &#62; $b)
     print "a is bigger than b";
 </PRE
><P
></P
></DIV
>

    </P
><P
>     Often you'd want to have more than one statement to be executed
     conditionally.  Of course, there's no need to wrap each statement
     with an <TT
CLASS="LITERAL"
>if</TT
> clause.  Instead, you can group
     several statements into a statement group.
     For example, this code would display <TT
CLASS="COMPUTEROUTPUT"
>a is bigger than
     b</TT
> if <TT
CLASS="REPLACEABLE"
><I
>$a</I
></TT
> is bigger than
     <TT
CLASS="REPLACEABLE"
><I
>$b</I
></TT
>, and would then assign the value of
     <TT
CLASS="REPLACEABLE"
><I
>$a</I
></TT
> into <TT
CLASS="REPLACEABLE"
><I
>$b</I
></TT
>:
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> if ($a &#62; $b) {
     print "a is bigger than b";
     $b = $a;
 }
 </PRE
><P
></P
></DIV
>
 
    </P
><P
>     If statements can be nested indefinitely within other
     <TT
CLASS="LITERAL"
>if</TT
> statements, which provides you with complete
     flexibility for conditional execution of the various parts of
     your program.
 
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CONSTRUCT.ELSE"
><TT
CLASS="LITERAL"
>else</TT
></A
></H2
><P
>     Often you'd want to execute a statement if a certain condition
     is met, and a different statement if the condition is not met.
     This is what <TT
CLASS="LITERAL"
>else</TT
> is for.  <TT
CLASS="LITERAL"
>else</TT
>
     extends an <TT
CLASS="LITERAL"
>if</TT
> statement to execute a statement
     in case the expression in the <TT
CLASS="LITERAL"
>if</TT
> statement
     evaluates to <TT
CLASS="LITERAL"
>FALSE</TT
>.  For example, the following
     code would display <TT
CLASS="COMPUTEROUTPUT"
>a is bigger than b</TT
>
     if <TT
CLASS="REPLACEABLE"
><I
>$a</I
></TT
> is bigger than <TT
CLASS="REPLACEABLE"
><I
>$b</I
></TT
>,
     and <TT
CLASS="COMPUTEROUTPUT"
>a is NOT bigger than b</TT
> otherwise:

     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> if ($a &#62; $b) {
     print "a is bigger than b";
 } else {
     print "a is NOT bigger than b";
 }
      </PRE
><P
></P
></DIV
>
 
     The <TT
CLASS="LITERAL"
>else</TT
> statement is only executed
     if the <TT
CLASS="LITERAL"
>if</TT
> expression evaluated to
     <TT
CLASS="LITERAL"
>FALSE</TT
>, and if there were any <TT
CLASS="LITERAL"
>elseif</TT
>
     expressions - only if they evaluated to <TT
CLASS="LITERAL"
>FALSE</TT
>
     as well (see below).
 
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CONSTRUCT.ELSEIF"
><TT
CLASS="LITERAL"
>elseif</TT
></A
></H2
><P
>     <TT
CLASS="LITERAL"
>elseif</TT
>, as its name suggests, is a combination
     of <TT
CLASS="LITERAL"
>if</TT
> and <TT
CLASS="LITERAL"
>else</TT
>.  Like
     <TT
CLASS="LITERAL"
>else</TT
>, it extends an <TT
CLASS="LITERAL"
>if</TT
>
     statement to execute a different statement in case the
     original <TT
CLASS="LITERAL"
>if</TT
> expression evaluates to
     <TT
CLASS="LITERAL"
>FALSE</TT
>.  However, unlike <TT
CLASS="LITERAL"
>else</TT
>,
     it will execute that alternative expression only if the
     <TT
CLASS="LITERAL"
>elseif</TT
> conditional expression evaluates to
     <TT
CLASS="LITERAL"
>TRUE</TT
>.  For example, the following code would
     display <TT
CLASS="COMPUTEROUTPUT"
>a is bigger than b</TT
>,
     <TT
CLASS="COMPUTEROUTPUT"
>a equal to b</TT
> or <TT
CLASS="COMPUTEROUTPUT"
>a
     is smaller than b</TT
>:
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> if ($a &#62; $b) {
     print "a is bigger than b";
 } elseif ($a == $b) {
     print "a is equal to b";
 } else {
     print "a is smaller than b";
 }
      </PRE
><P
></P
></DIV
>
 
    </P
><P
>     There may be several <TT
CLASS="LITERAL"
>elseif</TT
>s within the same
     <TT
CLASS="LITERAL"
>if</TT
> statement.  The first <TT
CLASS="LITERAL"
>elseif</TT
>
     expression (if any) that evaluates to <TT
CLASS="LITERAL"
>true</TT
>
     would be executed.  In PHP, you can also write 'else if' (in two
     words) and the behavior would be identical to the one of 'elseif'
     (in a single word).  The syntactic meaning is slightly different
     (if you're familiar with C, this is the same behavior) but the
     bottom line is that both would result in exactly the same behavior.
     
    </P
><P
>     The <TT
CLASS="LITERAL"
>elseif</TT
> statement is only executed if the preceding
     <TT
CLASS="LITERAL"
>if</TT
> expression and any
     preceding <TT
CLASS="LITERAL"
>elseif</TT
> expressions evaluated to <TT
CLASS="LITERAL"
>FALSE</TT
>, and the current
     <TT
CLASS="LITERAL"
>elseif</TT
> expression evaluated to <TT
CLASS="LITERAL"
>TRUE</TT
>.
 
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN2313"
>Alternative syntax for <TT
CLASS="LITERAL"
>if</TT
> structures: <TT
CLASS="LITERAL"
>if(): ... endif;</TT
></A
></H2
><P
>      PHP offers a different way to group statements within an
      <TT
CLASS="LITERAL"
>if</TT
> statement.  This is most commonly used when
      you nest HTML blocks inside <TT
CLASS="LITERAL"
>if</TT
> statements, but
      can be used anywhere.  Instead of using curly braces, <TT
CLASS="LITERAL"
>if
      (<TT
CLASS="REPLACEABLE"
><I
>expr</I
></TT
>)</TT
> should be followed
      by a colon, the list of one or more statements, and end with
      <TT
CLASS="LITERAL"
>endif;</TT
>.  Consider the following example:
 
      <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> &lt;?php if ($a==5): ?&gt;
 A = 5
 &lt;?php endif; ?&gt;
       </PRE
><P
></P
></DIV
>
 
     </P
><P
>      In the above example, the HTML block "A = 5" is nested within an
      <TT
CLASS="LITERAL"
>if</TT
> statement written in the alternative syntax.
      The HTML block would be displayed only if $a is equal to 5.
 
     </P
><P
>      The alternative syntax applies to <TT
CLASS="LITERAL"
>else</TT
>
      and <TT
CLASS="LITERAL"
>elseif</TT
> as well.  The following is an
      <TT
CLASS="LITERAL"
>if</TT
> structure with <TT
CLASS="LITERAL"
>elseif</TT
>
      and <TT
CLASS="LITERAL"
>else</TT
> in the alternative format:
      
      <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> if ($a == 5):
     print "a equals 5";
     print "...";
 elseif ($a == 6):
     print "a equals 6";
     print "!!!";
 else:
     print "a is neither 5 nor 6";
 endif;
       </PRE
><P
></P
></DIV
>
 
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CONSTRUCT.WHILE"
><TT
CLASS="LITERAL"
>while</TT
></A
></H2
><P
>     <TT
CLASS="LITERAL"
>while</TT
> loops are the simplest type of loop in PHP.
     They behave just like their C counterparts.  The basic form of a
     <TT
CLASS="LITERAL"
>while</TT
> statement is:
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> while (expr) statement
      </PRE
><P
></P
></DIV
>
 
    </P
><P
>     The meaning of a <TT
CLASS="LITERAL"
>while</TT
> statement is simple.
     It tells PHP to execute the nested statement(s) repeatedly,
     as long as the <TT
CLASS="LITERAL"
>while</TT
> expression evaluates
     to <TT
CLASS="LITERAL"
>TRUE</TT
>.  The value of the expression is
     checked each time at the beginning of the loop, so even if this
     value changes during the execution of the nested statement(s),
     execution will not stop until the end of the iteration (each
     time PHP runs the statements in the loop is one iteration).
     Sometimes, if the <TT
CLASS="LITERAL"
>while</TT
> expression evaluates
     to <TT
CLASS="LITERAL"
>FALSE</TT
> from the very beginning, the nested
     statement(s) won't even be run once.
 
    </P
><P
>     Like with the <TT
CLASS="LITERAL"
>if</TT
> statement, you can group
     multiple statements within the same <TT
CLASS="LITERAL"
>while</TT
> loop
     by surrounding a group of statements with curly braces, or by using
     the alternate syntax:
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
>     while (expr): statement ... endwhile;
 </PRE
><P
></P
></DIV
>
 
     </P
><P
>      The following examples are identical, and both print numbers from
      1 to 10:
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> /* example 1 */
 
 $i = 1;
 while ($i &#60;= 10) {
     print $i++;  /* the printed value would be
                     $i before the increment
                     (post-increment) */
 }
 
 /* example 2 */
 
 $i = 1;
 while ($i &#60;= 10):
     print $i;
     $i++;
 endwhile;
      </PRE
><P
></P
></DIV
>
 
 
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CONSTRUCT.DO.WHILE"
><TT
CLASS="LITERAL"
>do..while</TT
></A
></H2
><P
>     <TT
CLASS="LITERAL"
>do..while</TT
> loops are very similar to
     <TT
CLASS="LITERAL"
>while</TT
> loops, except the truth expression is
     checked at the end of each iteration instead of in the beginning.
     The main difference from regular <TT
CLASS="LITERAL"
>while</TT
> loops
     is that the first iteration of a <TT
CLASS="LITERAL"
>do..while</TT
>
     loop is guarenteed to run (the truth expression is only checked
     at the end of the iteration), whereas it's may not necessarily run
     with a regular <TT
CLASS="LITERAL"
>while</TT
> loop (the truth expression
     is checked at the beginning of each iteration, if it evaluates
     to <TT
CLASS="LITERAL"
>FALSE</TT
> right from the beginning, the loop
     execution would end immediately).

    </P
><P
>     There is just one syntax for <TT
CLASS="LITERAL"
>do..while</TT
> loops:
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> $i = 0;
 do {
     print $i;
 } while ($i&#62;0);
      </PRE
><P
></P
></DIV
>
 
    </P
><P
>     The above loop would run one time exactly, since after the first
     iteration, when truth expression is checked, it evaluates to
     <TT
CLASS="LITERAL"
>FALSE</TT
> ($i is not bigger than 0) and the loop
     execution ends.
 
    </P
><P
>     Advanced C users may be familiar with a different usage of
     the <TT
CLASS="LITERAL"
>do..while</TT
> loop, to allow stopping
     execution in the middle of code blocks, by encapsulating
     them with <TT
CLASS="LITERAL"
>do..while</TT
>(0), and using the <A
HREF="control-structures.html#CONSTRUCT.BREAK"
><TT
CLASS="LITERAL"
>break</TT
></A
> statement.
     The following code fragment demonstrates this:
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> do {
     if ($i &#60; 5) {
         print "i is not big enough";
         break;
     }
     $i *= $factor;
     if ($i &#60; $minimum_limit) {
         break;
     }
     print "i is ok";
     ...process i...
 } while(0);
      </PRE
><P
></P
></DIV
>
 
    </P
><P
>     Don't worry if you don't understand this right away or at all.
     You can code scripts and even powerful scripts without using this
     `feature'.
 
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CONSTRUCT.FOR"
><TT
CLASS="LITERAL"
>for</TT
></A
></H2
><P
>     <TT
CLASS="LITERAL"
>for</TT
> loops are the most complex loops in
     PHP.  They behave like their C counterparts.  The syntax of a
     <TT
CLASS="LITERAL"
>for</TT
> loop is:
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
>for (expr1; expr2; expr3) statement
      </PRE
><P
></P
></DIV
>
 
    </P
><P
>     The first expression (<TT
CLASS="REPLACEABLE"
><I
>expr1</I
></TT
>) is evaluated
     (executed) once unconditionally at the beginning of the loop.
 
    </P
><P
>     In the beginning of each iteration, <TT
CLASS="REPLACEABLE"
><I
>expr2</I
></TT
>
     is evaluated.  If it evaluates to <TT
CLASS="LITERAL"
>TRUE</TT
>, the
     loop continues and the nested statement(s) are executed.  If it
     evaluates to <TT
CLASS="LITERAL"
>FALSE</TT
>, the execution of the loop ends.
 
    </P
><P
>     At the end of each iteration, <TT
CLASS="REPLACEABLE"
><I
>expr3</I
></TT
>
     is evaluated (executed).

    </P
><P
>     Each of the expressions can be empty.
     <TT
CLASS="REPLACEABLE"
><I
>expr2</I
></TT
> being empty means
     the loop should be run indefinitely (PHP implicitly
     considers it as <TT
CLASS="LITERAL"
>TRUE</TT
>, like C).
     This may not be as useless as you might think, since
     often you'd want to end the loop using a conditional <A
HREF="control-structures.html#CONSTRUCT.BREAK"
><TT
CLASS="LITERAL"
>break</TT
></A
> statement
     instead of using the <TT
CLASS="LITERAL"
>for</TT
> truth expression.
 
    </P
><P
>     Consider the following examples.  All of them display numbers from
     1 to 10:
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> /* example 1 */
 
 for ($i = 1; $i &#60;= 10; $i++) {
     print $i;
 }
 
 /* example 2 */
 
 for ($i = 1;;$i++) {
     if ($i &#62; 10) {
         break;
     }
     print $i;
 }
 
 /* example 3 */
 
 $i = 1;
 for (;;) {
     if ($i &#62; 10) {
         break;
     }
     print $i;
     $i++;
 }
 
 /* example 4 */
 
 for ($i = 1; $i &#60;= 10; print $i, $i++) ;
      </PRE
><P
></P
></DIV
>
 
    </P
><P
>     Of course, the first example appears to be the nicest one (or
     perhaps the fourth), but you may find that being able to use empty
     expressions in <TT
CLASS="LITERAL"
>for</TT
> loops comes in handy in
     many occasions.
 
    </P
><P
>     PHP also supports the alternate "colon syntax" for
     <TT
CLASS="LITERAL"
>for</TT
> loops.
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> for (expr1; expr2; expr3): statement; ...; endfor;
      </PRE
><P
></P
></DIV
>
 
    </P
><P
>     Other languages have a foreach statement to traverse an array or
     hash. PHP uses the while statement and the <A
HREF="function.list.html"
><B
CLASS="FUNCTION"
>list()</B
></A
>
     and <A
HREF="function.each.html"
><B
CLASS="FUNCTION"
>each()</B
></A
> functions for this. See the
     documentation for these functions for an example.
 
 
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CONSTRUCT.BREAK"
><TT
CLASS="LITERAL"
>break</TT
></A
></H2
><P
>     <TT
CLASS="LITERAL"
>break</TT
> breaks out of the current looping construct.
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> $i = 0;
 while ($i &#60; 10) {
     if ($arr[$i] == "stop") {
         break;
     }
     $i++;
 }
      </PRE
><P
></P
></DIV
>
 
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CONSTRUCT.CONTINUE"
><TT
CLASS="LITERAL"
>continue</TT
></A
></H2
><P
>     <TT
CLASS="LITERAL"
>continue</TT
> jumps to the beginning of enclosing the looping
     construct.
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> while (list($key,$value) = each($arr)) {
     if ($key % 2) { // skip even members
         continue;
     }
     do_something_odd ($value);
 }
      </PRE
><P
></P
></DIV
>
 
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CONSTRUCT.SWITCH"
><TT
CLASS="LITERAL"
>switch</TT
></A
></H2
><P
>     The <TT
CLASS="LITERAL"
>switch</TT
> statement is similar to a series
     of IF statements on the same expression.  In many occasions,
     you may want to compare the same variable (or expression) with
     many different values, and execute a different piece of code
     depending on which value it equals to.  This is exactly what the
     <TT
CLASS="LITERAL"
>switch</TT
> statement is for.
 
    </P
><P
>     The following two examples are two different ways to write the
     same thing, one using a series of <TT
CLASS="LITERAL"
>if</TT
> statements,
     and the other using the <TT
CLASS="LITERAL"
>switch</TT
> statement:
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> /* example 1 */
 
 if ($i == 0) {
     print "i equals 0";
 }
 if ($i == 1) {
     print "i equals 1";
 }
 if ($i == 2) {
     print "i equals 2";
 }
 
 /* example 2 */
 
 switch ($i) {
     case 0:
         print "i equals 0";
         break;
     case 1:
         print "i equals 1";
         break;
     case 2:
         print "i equals 2";
         break;
 }
      </PRE
><P
></P
></DIV
>
 
    </P
><P
>     It is important to understand how the <TT
CLASS="LITERAL"
>switch</TT
>
     statement is executed in order to avoid messups.  The
     <TT
CLASS="LITERAL"
>switch</TT
> statement executes line by line (actually,
     statement by statement).  In the beginning, no code is executed.
     Only when a <TT
CLASS="LITERAL"
>case</TT
> statement is found with a value that matches the
     value of the <TT
CLASS="LITERAL"
>switch</TT
> expression, PHP begins to
     execute the statements.  PHP continues to execute the statements
     until the end of the <TT
CLASS="LITERAL"
>switch</TT
> block, or the first
     time it sees a <TT
CLASS="LITERAL"
>break</TT
> statement.  If you don't
     write a <TT
CLASS="LITERAL"
>break</TT
> statement at the end of a case's
     statement list, PHP will go on executing the statements of the
     following case.  For example:
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> /* example 3 */
 
 switch ($i) {
     case 0:
         print "i equals 0";
     case 1:
         print "i equals 1";
     case 2:
         print "i equals 2";
 }
      </PRE
><P
></P
></DIV
>
 
    </P
><P
>     Here, if $i equals to 0, PHP would execute all of the print
     statements!  If $i equals to 1, PHP would execute the last
     two print statements, and only if $i equals to 2, you'd get the
     'expected' behavior and only 'i equals 2' would be displayed.  So,
     it's important not to forget <TT
CLASS="LITERAL"
>break</TT
> statements
     (even though you may want to avoid supplying them on purpose under
     certain circumstances).
 
    </P
><P
>     A special case is the default case.  This case matches anything
     that wasn't matched by the other cases.  For example:
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> /* example 4 */
 
 switch ($i) {
     case 0:
         print "i equals 0";
         break;
     case 1:
         print "i equals 1";
         break;
     case 2:
         print "i equals 2";
         break;
     default:
         print "i is not equal to 0, 1 or 2";
 }
      </PRE
><P
></P
></DIV
>
 
    </P
><P
>     Another fact worth mentioning is that the <TT
CLASS="LITERAL"
>case</TT
>
     expression may be any expression that evaluates to a scalar type,
     that is, integer or floating-point numbers and strings.  Arrays or
     objects are meaningless in that context.
 
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTION.REQUIRE"
><TT
CLASS="LITERAL"
>require</TT
></A
></H2
><P
>     The <TT
CLASS="LITERAL"
>require</TT
> statement replaces itself with the
     specified file, much like the C preprocessor's #include works.

    </P
><P
>     This means that you can't put a <TT
CLASS="LITERAL"
>require</TT
>
     statement inside of a loop structure and expect it to include the
     contents of a different file on each iteration. To do that, use an
     <TT
CLASS="LITERAL"
>include</TT
> statement.
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> require 'header.inc';
      </PRE
><P
></P
></DIV
>
 
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTION.INCLUDE"
><TT
CLASS="LITERAL"
>include</TT
></A
></H2
><P
>     The <TT
CLASS="LITERAL"
>include</TT
> statement includes and evaluates
     the specified file.
 
    </P
><P
>     This happens each time the <TT
CLASS="LITERAL"
>include</TT
> statement is
     encountered, so you can use an <TT
CLASS="LITERAL"
>include</TT
> statement
     within a looping structure to include a number of different file.
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> $files = array ('first.inc', 'second.inc', 'third.inc');
 for ($i = 0; $i &#60; count($files); $i++) {
     include $files[$i];
 }
      </PRE
><P
></P
></DIV
>

    </P
><P
>     <A
HREF="control-structures.html#FUNCTION.INCLUDE"
><TT
CLASS="LITERAL"
>include</TT
></A
>
     differs from <A
HREF="control-structures.html#FUNCTION.REQUIRE"
><TT
CLASS="LITERAL"
>require</TT
></A
>
     in that the include statement is re-evaluated each time it is
     encountered (and only when it is being executed), whereas the
     <A
HREF="control-structures.html#FUNCTION.REQUIRE"
><TT
CLASS="LITERAL"
>require</TT
></A
>
     statement is replaced by the required file when it is first
     encountered, whether the contents of the file will be evaluated or
     not (for example, if it is inside an if statement whose condition
     evaluated to false).
 
    </P
><P
>     Because <A
HREF="control-structures.html#FUNCTION.INCLUDE"
><TT
CLASS="LITERAL"
>include</TT
></A
> is a
     special language construct, you must enclose it within a statement
     block if it is inside a conditional block.
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> /* This is WRONG and will not work as desired. */
 
 if ($condition)
     include($file);
 else
     include($other);
 
 /* This is CORRECT. */
 
 if ($condition) {
     include($file);
 } else {
     include($other);
 }
      </PRE
><P
></P
></DIV
>
 
    </P
><P
>     When the file is evaluated, the parser begins in "HTML-mode" which
     will output the contents of the file until the first PHP start tag
     (&lt;?)  is encountered.

    </P
><P
>     See also <A
HREF="function.readfile.html"
><B
CLASS="FUNCTION"
>readfile()</B
></A
>, <A
HREF="control-structures.html#FUNCTION.REQUIRE"
><B
CLASS="FUNCTION"
>require()</B
></A
>,
     <A
HREF="function.virtual.html"
><B
CLASS="FUNCTION"
>virtual()</B
></A
>.
 
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="KEYWORD.FUNCTION"
><TT
CLASS="LITERAL"
>function</TT
></A
></H2
><P
>     A function may be defined using syntax such as the following:
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> function foo ($arg_1, $arg_2, ..., $arg_n) {
     echo "Example function.\n";
     return $retval;
 }
      </PRE
><P
></P
></DIV
>
     
    </P
><P
>     Any valid PHP code may appear inside a function, even other
     functions and <A
HREF="control-structures.html#KEYWORD.CLASS"
>class</A
>
     definitions.
     
    </P
><P
>     Functions must be defined before they are referenced.
 
    </P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="KEYWORD.FUNCTION.RETURN"
>Returning values</A
></H3
><P
>      Values are returned by using the optional return statement. Any
      type may be returned, including lists and objects.
 
      <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> function my_sqrt ($num) {
     return $num * $num;
 }
 echo my_sqrt (4);   // outputs '16'.
       </PRE
><P
></P
></DIV
>
      
     </P
><P
>      Multiple values may not be returned, but the same effect can be
      achieved by returning a list:
 
      <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> function foo() {
    return array (0, 1, 2);
 }
 list ($zero, $one, $two) = foo();
       </PRE
><P
></P
></DIV
>
 
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="KEYWORD.FUNCTION.ARGUMENTS"
>Arguments</A
></H3
><P
>      Information may be passed to functions via the argument list,
      which is a comma-delimited list of variables and/or constants.
 
     </P
><P
>      PHP supports passing arguments by value (the default), <A
HREF="control-structures.html#KEYWORD.FUNCTION.ARGUMENTS.REFERENCE"
>passing by
      reference</A
>, and <A
HREF="control-structures.html#KEYWORD.FUNCTION.ARGUMENTS.DEFAULT"
>default argument
      values</A
>. Variable-length argument lists are not supported,
      but a similar effect may be achieved by passing arrays.
 
      <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> function takes_array($input) {
     echo "$input[0] + $input[1] = ", $input[0]+$input[1];
 }
       </PRE
><P
></P
></DIV
>
 
     </P
><DIV
CLASS="SECT4"
><H4
CLASS="SECT4"
><A
NAME="KEYWORD.FUNCTION.ARGUMENTS.REFERENCE"
>Passing by reference</A
></H4
><P
>       By default, function arguments are passed by value. If you wish
       to allow a function to modify its arguments, you may pass them
       by reference.
       
      </P
><P
>       If you wish a function's argument to always be passed by
       reference, you can prepend an ampersand (&amp;) to the argument
       name in the function definition:
 
       <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> function foo( &amp;$bar ) {
     $bar .= 'and something extra.';
 }
 $str = 'This is a string, ';
 foo ($str);
 echo $str;    // outputs 'This is a string, and something extra.'
        </PRE
><P
></P
></DIV
>
 
      </P
><P
>       If you wish to pass a variable by reference to a function which
       does not do this by default, you may prepend an ampersand to the 
       argument name in the function call:
 
       <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> function foo ($bar) {
     $bar .= ' and something extra.';
 }
 $str = 'This is a string, ';
 foo ($str);
 echo $str;    // outputs 'This is a string, '
 foo (&amp;$str);
 echo $str;    // outputs 'This is a string, and something extra.'
        </PRE
><P
></P
></DIV
>
 
     </P
></DIV
><DIV
CLASS="SECT4"
><H4
CLASS="SECT4"
><A
NAME="KEYWORD.FUNCTION.ARGUMENTS.DEFAULT"
>Default values</A
></H4
><P
>       A function may define C++-style default values for scalar
       arguments as follows:
 
       <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> function makecoffee ($type = "cappucino") {
     echo "Making a cup of $type.\n";
 }
 echo makecoffee ();
 echo makecoffee ("espresso");
        </PRE
><P
></P
></DIV
>
 
      </P
><P
>       The output from the above snippet is:
 
       <PRE
CLASS="SCREEN"
> Making a cup of cappucino.
 Making a cup of espresso.
       </PRE
>
 
      </P
><P
>       The default value must be a constant expression, not (for
       example) a variable or class member.
 
      </P
><P
>       Note that when using default arguments, any defaults should be
       on the right side of any non-default arguments; otherwise,
       things will not work as expected. Consider the following code
       snippet:
 
       <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> function makeyogurt ($type = "acidophilus", $flavour) {
     return "Making a bowl of $type $flavour.\n";
 }
 
 echo makeyogurt ("raspberry");   // won't work as expected
        </PRE
><P
></P
></DIV
>
 
      </P
><P
>       The output of the above example is:
 
       <PRE
CLASS="SCREEN"
> Warning: Missing argument 2 in call to makeyogurt() in 
 /usr/local/etc/httpd/htdocs/php3test/functest.html on line 41
 Making a bowl of raspberry .
       </PRE
>
 
      </P
><P
>       Now, compare the above with this:
 
       <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> function makeyogurt ($flavour, $type = "acidophilus") {
     return "Making a bowl of $type $flavour.\n";
 }
 
 echo makeyogurt ("raspberry");   // works as expected
        </PRE
><P
></P
></DIV
>
 
      </P
><P
>       The output of this example is:
 
       <PRE
CLASS="SCREEN"
> Making a bowl of acidophilus raspberry.
      </PRE
>
 
     </P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="KEYWORD.OLD-FUNCTION"
><TT
CLASS="LITERAL"
>old_function</TT
></A
></H2
><P
>     The <TT
CLASS="LITERAL"
>old_function</TT
> statement allows you to declare
     a function using a syntax identical to PHP/FI2 (except you must
     replace 'function' with 'old_function'.
    </P
><P
>     This is a deprecated feature, and should only be used by the
     PHP/FI2-&#62;PHP3 convertor.
    </P
><P
>     Functions declared as <TT
CLASS="LITERAL"
>old_function</TT
>
     cannot be called from PHP's internal code. Among other
     things, this means you can't use them in functions such as
     <A
HREF="function.usort.html"
><B
CLASS="FUNCTION"
>usort()</B
></A
>, <A
HREF="function.array-walk.html"
><B
CLASS="FUNCTION"
>array_walk()</B
></A
>, and
     <A
HREF="function.register-shutdown-function.html"
><B
CLASS="FUNCTION"
>register_shutdown_function()</B
></A
>. You can get around
     this limitation by writing a wrapper function (in normal PHP3 form)
     to call the <TT
CLASS="LITERAL"
>old_function</TT
>.
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="KEYWORD.CLASS"
><TT
CLASS="LITERAL"
>class</TT
></A
></H2
><P
>     A class is a collection of variables and functions working with
     these variables.  A class is defined using the following syntax:
 
     <DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> &lt;?php
 class Cart {
     var $items;  // Items in our shopping cart
   
     // Add $num articles of $artnr to the cart
 
     function add_item ($artnr, $num) {
         $this-&#62;items[$artnr] += $num;
     }
   
     // Take $num articles of $artnr out of the cart
 
     function remove_item ($artnr, $num) {
         if ($this-&#62;items[$artnr] &#62; $num) {
             $this-&#62;items[$artnr] -= $num;
             return true;
         } else {
             return false;
         }   
     }
 }
 ?&#62;
      </PRE
><P
></P
></DIV
>
 
    </P
><P
>     This defines a class named Cart that consists of an associative
     array of articles in the cart and two functions to add and remove
     items from this cart.
 
    </P
><P
>     Classes are types, that is, they are blueprints for actual
     variables. You have to create a variables of the desired type with
     the new operator.
    </P
><DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> $cart = new Cart;
 $cart-&#62;add_item("10", 1);
     </PRE
><P
></P
></DIV
><P
>     This creates an object $cart of the class Cart. The function
     add_item() of that object is being called to add 1 item of article
     number 10 to the cart.
    </P
><P
>     Classes can be extensions of other classes. The extended or
     derived class has all variables and functions of the base class
     and what you add in the extended definition.  This is done using
     the extends keyword.
    </P
><DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> class Named_Cart extends Cart {
     var $owner;
  
     function set_owner ($name) {
         $this-&#62;owner = $name;
     }
 }
     </PRE
><P
></P
></DIV
><P
>     This defines a class Named_Cart that has all variables and
     functions of Cart plus an additional variable $owner and an
     additional function set_owner(). You create a named cart the usual
     way and can now set and get the carts owner. You can still use
     normal cart functions on named carts:
    </P
><DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> $ncart = new Named_Cart;    // Create a named cart
 $ncart-&#62;set_owner ("kris"); // Name that cart
 print $ncart-&#62;owner;        // print the cart owners name
 $ncart-&#62;add_item ("10", 1); // (inherited functionality from cart)
     </PRE
><P
></P
></DIV
><P
>     Within functions of a class the variable $this means this
     object. You have to use $this-&#62;something to access any variable or
     function named something within your current object.
    </P
><P
>     Constructors are functions in a class that are automatically 
     called when you create a new instance of a class. A function 
     becomes a constructor when it has the same name as the class.
    </P
><DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> class Auto_Cart extends Cart {
     function Auto_Cart () {
         $this-&#62;add_item ("10", 1);
     }
 }
     </PRE
><P
></P
></DIV
><P
>     This defines a class Auto_Cart that is a Cart plus a constructor
     which initializes the cart with one item of article number "10"
     each time a new Auto_Cart is being made with "new". Constructors
     can also take arguments and these arguments can be optional, which
     makes them much more useful.
    </P
><DIV
CLASS="INFORMALEXAMPLE"
><P
></P
><PRE
CLASS="PROGRAMLISTING"
> class Constructor_Cart {
     function Constructor_Cart ($item = "10", $num = 1) {
         $this-&#62;add_item ($item, $num);
     }
 }
 
 // Shop the same old boring stuff.
 
 $default_cart   = new Constructor_Cart;
 
 // Shop for real...
 
 $different_cart = new Constructor_Cart ("20", 17);
     </PRE
><P
></P
></DIV
><DIV
CLASS="CAUTION"
><P
></P
><TABLE
CLASS="CAUTION"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Caution</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>      For derived classes, the constructor of the parent class is not
      automatically called when the derived class's constructor is called.
    </P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="operators.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="manual.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="funcref.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Operators</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="lang-syntax.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Function Reference</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>