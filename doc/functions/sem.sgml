
 <reference id="ref.sem">
  <title>Semaphore and Shared Memory Functions</title>
  <titleabbrev>Semaphore</titleabbrev>
  <partintro>
  <para>
   This module provides semaphore functions using System V semaphores.
   Semaphores may be used to provide exclusive access to resources
   on the current machine, or to limit the number of processes that
   may simultaneously use a resource.
  <para>
   Shared memory support is also included. It is compatible with
   System V compatible systems.
  </partintro>

  <refentry id="function.sem-get">
   <refnamediv>
    <refname>sem_get</refname>
    <refpurpose>get a semaphore id</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcdef>int <function>sem_get</function></funcdef>
     <paramdef>int <parameter>key</parameter></paramdef>
     <paramdef>int <parameter><optional>max_acquire</optional>
      </parameter></paramdef>
     <paramdef>int <parameter><optional>perm</optional>
      </parameter></paramdef>
    </funcsynopsis>
    <para>
     Returns: A positive semaphore identifier on success, or false on
     error.
    <para>
     <function>sem_get</function> returns an id that can be used to
     access the System V semaphore with the given key.  The semaphore
     is created if necessary using the permission bits specified in
     perm (defaults to 0666).  The number of processes that can
     acquire the semaphore simultaneously is set to max_acquire
     (defaults to 1).  Actually this value is set only if the process
     finds it is the only process currently attached to the semaphore.
    <para>
     A second call to <function>sem_get</function> for the same key
     will return a different semaphore identifier, but both
     identifiers access the same underlying semaphore.  
    <para> 
     See also: <function>sem_acquire</function> and
     <function>sem_release</function>.
   </refsect1>
  </refentry>

  <refentry id="function.sem-acquire">
   <refnamediv>
    <refname>sem_acquire</refname>
    <refpurpose>acquire a semaphore</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcdef>int <function>sem_acquire</function></funcdef>
     <paramdef>int <parameter>sem_identifier</parameter></paramdef>
    </funcsynopsis>
    <para>
     Returns: true on success, false on error
    <para>
     <function>sem_acquire</function> blocks (if necessary) until the
     semaphore can be acquired.  A process attempting to acquire a
     semaphore which it has already acquired will block forever
     if acquiring the semaphore would cause its max_acquire value to
     be exceeded.
    <para>
     After processing a request, any semaphores acquired by the
     process but not explicitly released will be released automatically
     and a warning will be generated.
    <para> 
     See also: <function>sem_get</function> and
               <function>sem_release</function>.
   </refsect1>
  </refentry>

  <refentry id="function.sem-release">
   <refnamediv>
    <refname>sem_release</refname>
    <refpurpose>release a semaphore</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcdef>int <function>sem_release</function></funcdef>
     <paramdef>int <parameter>sem_identifier</parameter></paramdef>
    </funcsynopsis>
    <para>
     Returns: true on success, false on error
    <para>
     <function>sem_release</function> releases the semaphore if it
     is currently acquired by the calling process, otherwise
     a warning is generated.
    <para>
      After releasing the semaphore, <function>sem_acquire</function>
      may be called to re-acquire it.
    <para> 
     See also: <function>sem_get</function> and
               <function>sem_acquire</function>.
   </refsect1>
  </refentry>

  <refentry id="function.shm-attach">
   <refnamediv>
    <refname>shm_attach</refname>
    <refpurpose>Creates or open a shared memory</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcdef>int <function>shm_attach</function></funcdef>
     <paramdef>long <parameter>key</parameter></paramdef>
     <paramdef>long <parameter>memsize</parameter></paramdef>
     <paramdef>long <parameter>perm</parameter></paramdef>
    </funcsynopsis>
    <para>
     Creates or open a shared memory with the given key and 
     memsize.
   </refsect1>
  </refentry>

  <refentry id="function.shm-detach">
   <refnamediv>
    <refname>shm_detach</refname>
    <refpurpose>Disconnects from shared memory</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcdef>int <function>shm_detach</function></funcdef>
     <paramdef>long <parameter>id</parameter></paramdef>
    </funcsynopsis>
    <para>
     Disconnects from shared memory with the given
     <parameter>id</parameter> created from
     <function>shm_attach</function>. Remember, that the shared memory
     still exist in the Unix system and the data is still present.
   </refsect1>
  </refentry>

  <refentry id="function.shm-put-var">
   <refnamediv>
    <refname>shm_put_var</refname> 
    <refpurpose>Inserts or updates a variable in shared
     memory</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcdef>int <function>shm_put_var</function></funcdef>
     <paramdef>int <parameter>id</parameter></paramdef>
     <paramdef>long <parameter>variable_key</parameter></paramdef>
     <paramdef>mixed <parameter>variable</parameter></paramdef>
    </funcsynopsis>
    <para>
     Inserts or updates a variable with a given variable_key. All
     variable-types (double, long, string, array) are supported. The
     function <function>serialize</function> can be used to store the
     data.
   </refsect1>
  </refentry>

  <refentry id="function.shm-get-var">
   <refnamediv>
    <refname>shm_put_var</refname> 
    <refpurpose>Reads a variable with a given variable_key
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcdef>mixed <function>shm_get_var</function></funcdef>
     <paramdef>int <parameter>id</parameter></paramdef>
     <paramdef>long <parameter>variable_key</parameter></paramdef>
    </funcsynopsis>
    <para>
     Reads a variable with a given <parameter>variable_key</parameter>.
     The variable is still present in the shared memory. The function
     <function>unserialize</function> can be used to decode the data.
   </refsect1>
  </refentry>

  <refentry id="function.shm-remove-var">
   <refnamediv>
    <refname>shm_remove_var</refname> 
    <refpurpose>Removes a variable from shared memory
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcdef>int <function>shm_remove_var</function></funcdef>
     <paramdef>int <parameter>id</parameter></paramdef>
     <paramdef>long <parameter>variable_key</parameter></paramdef>
    </funcsynopsis>
    <para>
     Removes a variable with a given <parameter>variable_key</parameter>
     from shared memory.
   </refsect1>
  </refentry>

  <refentry id="function.shm-remove">
   <refnamediv>
    <refname>shm_remove</refname> 
    <refpurpose>Removes shared memory</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcdef>int <function>shm_remove</function></funcdef>
     <paramdef>long <parameter>key</parameter></paramdef>
    </funcsynopsis>
    <para>
     Removes shared memory from the Unix system. All data will be
     destroyed.
   </refsect1>
  </refentry>



<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
